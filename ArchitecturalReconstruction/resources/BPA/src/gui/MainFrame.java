package gui;

import commands.Command;
import commands.CommandCellLocked;
import commands.CommandCellReplace;
import commands.CompoundCommand;
import controllers.GridController;
import controllers.LogController;
import java.awt.Point;
import javax.swing.SwingWorker;
import model.Cell;
import model.Grid;
import solvers.BacktrackListener;
import solvers.Backtracker;

/**
 * The mainframe of the BPA.
 *
 * @author Ruud Andriessen, 0770663
 * @since Saturday March 9
 */
public class MainFrame extends javax.swing.JFrame {

    /**
     * The grid controller that manages the current state
     */
    GridController gc;
    /**
     * The log controller that manages the log
     */
    LogController logger;
    /**
     * Whether we apply the fill third strategy
     */
    boolean applyFillThird;
    /**
     * Whether we apply the fill column/row strategy
     */
    boolean applyFillColumnRow;
    /**
     * Whether we apply the contradiction strategy
     */
    boolean applyContradiction;
    /**
     * Whether we apply the recurisive decorator or not
     */
    boolean applyRecursive;
    /**
     * Whether we are in edit mode
     */
    boolean editMode;

    /**
     * Creates new form MainFrame
     */
    public MainFrame() {
        initComponents();
        gc = new GridController();
        logger = new LogController(DebugPaneText);
        puzzlePanel.setShowErrorsImmediately(true);
        applyFillThird = false;
        applyFillColumnRow = false;
        applyContradiction = false;
        applyRecursive = false;
        editMode = false;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        puzzlePanel = new gui.PuzzlePanel();
        DebugScrollPane = new javax.swing.JScrollPane();
        DebugPaneText = new javax.swing.JTextPane();
        backtrackerProgress = new javax.swing.JProgressBar();
        jButton1 = new javax.swing.JButton();
        MenuBar = new javax.swing.JMenuBar();
        MenuOpen = new javax.swing.JMenu();
        FileOpen = new javax.swing.JMenuItem();
        MenuSave = new javax.swing.JMenuItem();
        FileQuit = new javax.swing.JMenuItem();
        MenuEdit = new javax.swing.JMenu();
        PuzzleUndo = new javax.swing.JMenuItem();
        PuzzleUndoAll = new javax.swing.JMenuItem();
        PuzzleRedo = new javax.swing.JMenuItem();
        PuzzleRedoAll = new javax.swing.JMenuItem();
        MenuAssist = new javax.swing.JMenu();
        AssistanceCheck = new javax.swing.JMenuItem();
        AssitanceSolve = new javax.swing.JMenu();
        AssitanceSolveOne = new javax.swing.JMenuItem();
        AssistanceSolveAll = new javax.swing.JMenuItem();
        ApplyStrategies = new javax.swing.JMenu();
        StratFillThird = new javax.swing.JCheckBoxMenuItem();
        StratFillColumnRow = new javax.swing.JCheckBoxMenuItem();
        StratContradiction = new javax.swing.JCheckBoxMenuItem();
        MenuSettings = new javax.swing.JMenu();
        SettingRecursiveStrategy = new javax.swing.JCheckBoxMenuItem();
        SettingShowErrors = new javax.swing.JCheckBoxMenuItem();
        SettingEditMode = new javax.swing.JCheckBoxMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Binary Puzzle Assistant (BPA)â„¢");
        setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));

        puzzlePanel.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mousePressed(java.awt.event.MouseEvent evt) {
                puzzlePanelMousePressed(evt);
            }
        });

        javax.swing.GroupLayout puzzlePanelLayout = new javax.swing.GroupLayout(puzzlePanel);
        puzzlePanel.setLayout(puzzlePanelLayout);
        puzzlePanelLayout.setHorizontalGroup(
            puzzlePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 780, Short.MAX_VALUE)
        );
        puzzlePanelLayout.setVerticalGroup(
            puzzlePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 353, Short.MAX_VALUE)
        );

        DebugScrollPane.setVerticalScrollBarPolicy(javax.swing.ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);

        DebugPaneText.setEditable(false);
        DebugScrollPane.setViewportView(DebugPaneText);

        jButton1.setText("Abort");
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        MenuOpen.setText("File");

        FileOpen.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_MASK));
        FileOpen.setText("Open");
        FileOpen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                FileOpenActionPerformed(evt);
            }
        });
        MenuOpen.add(FileOpen);

        MenuSave.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_MASK));
        MenuSave.setText("Save");
        MenuSave.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                MenuSaveActionPerformed(evt);
            }
        });
        MenuOpen.add(MenuSave);

        FileQuit.setText("Quit");
        FileQuit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                FileQuitActionPerformed(evt);
            }
        });
        MenuOpen.add(FileQuit);

        MenuBar.add(MenuOpen);

        MenuEdit.setText("Edit");

        PuzzleUndo.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Z, java.awt.event.InputEvent.CTRL_MASK));
        PuzzleUndo.setText("Undo");
        PuzzleUndo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                PuzzleUndoActionPerformed(evt);
            }
        });
        MenuEdit.add(PuzzleUndo);

        PuzzleUndoAll.setText("Undo All");
        PuzzleUndoAll.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                PuzzleUndoAllActionPerformed(evt);
            }
        });
        MenuEdit.add(PuzzleUndoAll);

        PuzzleRedo.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_Y, java.awt.event.InputEvent.CTRL_MASK));
        PuzzleRedo.setText("Redo");
        PuzzleRedo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                PuzzleRedoActionPerformed(evt);
            }
        });
        MenuEdit.add(PuzzleRedo);

        PuzzleRedoAll.setText("Redo All");
        PuzzleRedoAll.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                PuzzleRedoAllActionPerformed(evt);
            }
        });
        MenuEdit.add(PuzzleRedoAll);

        MenuBar.add(MenuEdit);

        MenuAssist.setText("Assistance");

        AssistanceCheck.setText("Check puzzle");
        AssistanceCheck.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                AssistanceCheckActionPerformed(evt);
            }
        });
        MenuAssist.add(AssistanceCheck);

        AssitanceSolve.setText("Solve puzzle");

        AssitanceSolveOne.setText("Solve");
        AssitanceSolveOne.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                AssitanceSolveOneActionPerformed(evt);
            }
        });
        AssitanceSolve.add(AssitanceSolveOne);

        AssistanceSolveAll.setText("Solve all");
        AssistanceSolveAll.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                AssistanceSolveAllActionPerformed(evt);
            }
        });
        AssitanceSolve.add(AssistanceSolveAll);

        MenuAssist.add(AssitanceSolve);

        ApplyStrategies.setText("Apply strategies");

        StratFillThird.setText("Triplet");
        StratFillThird.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                StratFillThirdActionPerformed(evt);
            }
        });
        ApplyStrategies.add(StratFillThird);

        StratFillColumnRow.setText("Line");
        StratFillColumnRow.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                StratFillColumnRowActionPerformed(evt);
            }
        });
        ApplyStrategies.add(StratFillColumnRow);

        StratContradiction.setText("Contradiction");
        StratContradiction.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                StratContradictionActionPerformed(evt);
            }
        });
        ApplyStrategies.add(StratContradiction);

        MenuAssist.add(ApplyStrategies);

        MenuBar.add(MenuAssist);

        MenuSettings.setText("Settings");

        SettingRecursiveStrategy.setText("Apply strategies until no change");
        SettingRecursiveStrategy.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SettingRecursiveStrategyActionPerformed(evt);
            }
        });
        MenuSettings.add(SettingRecursiveStrategy);

        SettingShowErrors.setSelected(true);
        SettingShowErrors.setText("Show errors automatically");
        SettingShowErrors.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SettingShowErrorsActionPerformed(evt);
            }
        });
        MenuSettings.add(SettingShowErrors);

        SettingEditMode.setText("Edit mode");
        SettingEditMode.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                SettingEditModeActionPerformed(evt);
            }
        });
        MenuSettings.add(SettingEditMode);

        MenuBar.add(MenuSettings);

        setJMenuBar(MenuBar);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(DebugScrollPane)
                    .addComponent(puzzlePanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(javax.swing.GroupLayout.Alignment.LEADING, layout.createSequentialGroup()
                        .addComponent(backtrackerProgress, javax.swing.GroupLayout.PREFERRED_SIZE, 712, javax.swing.GroupLayout.PREFERRED_SIZE)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jButton1)
                        .addGap(0, 0, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(puzzlePanel, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jButton1, javax.swing.GroupLayout.PREFERRED_SIZE, 0, Short.MAX_VALUE)
                    .addComponent(backtrackerProgress, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(DebugScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 128, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    /**
     * Executed when a user wishes to open a file.
     *
     * @param evt The action performed.
     */
    private void FileOpenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_FileOpenActionPerformed
        String r = gc.load();
        if (r != null) {
            outputMessage(r, "Info");
            puzzlePanel.setPuzzle(gc.getGameState());
        }
        repaint();
    }//GEN-LAST:event_FileOpenActionPerformed

    /**
     * Executed when a user wishes to quit the application.
     *
     * @param evt The action performed.
     */
    private void FileQuitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_FileQuitActionPerformed
        System.exit(0);
    }//GEN-LAST:event_FileQuitActionPerformed

    /**
     * Executed when the user wishes to save a file
     *
     * @param evt The action performed
     */
    private void MenuSaveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_MenuSaveActionPerformed
        String r = gc.save();
        if (r != null) {
            outputMessage(r, "Info");
        }
        repaint();
    }//GEN-LAST:event_MenuSaveActionPerformed

    private void PuzzleUndoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_PuzzleUndoActionPerformed
        try {
            if (gc.getGameState() != null) {
                gc.getGameState().undo();
            }
        } catch (IllegalStateException e) {
            outputMessage("No action to undo", "Info");
        }
        repaint();
    }//GEN-LAST:event_PuzzleUndoActionPerformed

    private void PuzzleRedoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_PuzzleRedoActionPerformed
        try {
            if (gc.getGameState() != null) {
                gc.getGameState().redo();
            }
        } catch (IllegalStateException e) {
            outputMessage("No action to redo", "Info");
        }
        repaint();
    }//GEN-LAST:event_PuzzleRedoActionPerformed

    //<editor-fold defaultstate="collapsed" desc="Mouse events">
    private void puzzlePanelMousePressed(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_puzzlePanelMousePressed
        // If there is an active puzzle
        Point p = evt.getPoint();
        Cell c = puzzlePanel.getCell(p);
        if (!editMode) {
            handleCellValueChange(c, evt.isAltDown());
        } else {
            handleLockedCellChange(c, evt.isAltDown());
        }
    }//GEN-LAST:event_puzzlePanelMousePressed

    /**
     * Handles clicking on the puzzlePanel while not in edit mode
     *
     * @param c The cell which is clicked
     * @param altDown Whether alt is down or not
     */
    private void handleCellValueChange(Cell c, boolean altDown) {
        if (c != null) {
            Command a;
            // Get the corresponding command
            if (!altDown) {
                // If alt is not down, rotate
                a = new CommandCellReplace(c, c.getValue().next());
            } else {
                // If alt is down, rotate the other way
                a = new CommandCellReplace(c, c.getValue().prev());
            }

            try {
                // Try to apply the command
                gc.getGameState().applyAction(a, true);
                // And execute all strategies
                gc.applyStrategies();
                repaint();
            } catch (IllegalStateException e) {
                // Output logger message
                outputMessage(e.getMessage(), "Warning");
            }
        }
    }

    /**
     * Handles clicking on the puzzlePanel while in edit mode
     *
     * @param p The cell which is clicked
     */
    private void handleLockedCellChange(Cell c, boolean altDown) {
        if (c != null) {
            Command a;
            if (!altDown) {
                a = new CommandCellLocked(c, !c.getLocked());
            } else {
                CompoundCommand command = new CompoundCommand();
                if (c.getLocked()) {
                    command.add(new CommandCellLocked(c, false));
                    command.add(new CommandCellReplace(c, c.getValue().next()));
                    command.add(new CommandCellLocked(c, true));
                } else {
                    command.add(new CommandCellReplace(c, c.getValue().next()));
                }
                a = command;
            }

            // Try to apply the command
            try {
                gc.getGameState().applyAction(a, true);
                repaint();
            } catch (IllegalStateException e) {
                // Output logger message
                outputMessage(e.getMessage(), "Warning");
            }
        }
    }
    //</editor-fold>

    private void SettingShowErrorsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SettingShowErrorsActionPerformed
        puzzlePanel.setShowErrorsImmediately(!puzzlePanel.getShowErrorsImmediately());
        repaint();
    }//GEN-LAST:event_SettingShowErrorsActionPerformed

    private void AssistanceCheckActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_AssistanceCheckActionPerformed
        if (gc.getGameState() != null) {
            if (gc.getGameState().hasViolation()) {
                outputMessage("There are still some errors", "Warning");
            } else {
                outputMessage("There are no errors in the puzzle so far", "Info");
            }
        }
    }//GEN-LAST:event_AssistanceCheckActionPerformed

    //<editor-fold defaultstate="collapsed" desc="Strategy change events">    
    private void StratFillColumnRowActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_StratFillColumnRowActionPerformed
        applyFillColumnRow = !applyFillColumnRow;
        gc.setLineStrategy(applyFillColumnRow);
        gc.applyStrategies();
        repaint();
    }//GEN-LAST:event_StratFillColumnRowActionPerformed

    private void StratFillThirdActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_StratFillThirdActionPerformed
        applyFillThird = !applyFillThird;
        gc.setTripletStrategy(applyFillThird);
        gc.applyStrategies();
        repaint();
    }//GEN-LAST:event_StratFillThirdActionPerformed
    //</editor-fold>

    //<editor-fold defaultstate="collapsed" desc="Solve events">    
    private void AssitanceSolveOneActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_AssitanceSolveOneActionPerformed
        if (gc.getGameState() != null) {
            backtrackWorker = new BacktrackWorker(true);
            backtrackWorker.execute();
        }
    }//GEN-LAST:event_AssitanceSolveOneActionPerformed

    private void AssistanceSolveAllActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_AssistanceSolveAllActionPerformed
        if (gc.getGameState() != null) {
            backtrackWorker = new BacktrackWorker(false);
            backtrackWorker.execute();
        }
    }//GEN-LAST:event_AssistanceSolveAllActionPerformed

    private void SettingEditModeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SettingEditModeActionPerformed
        editMode = !editMode;
        if (gc.getGameState() != null) {
            gc.getGameState().clear();
        }
        outputMessage("Changed edit mode to: " + editMode, "Info");
    }//GEN-LAST:event_SettingEditModeActionPerformed

    private void StratContradictionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_StratContradictionActionPerformed
        applyContradiction = !applyContradiction;
        gc.setContradictionStrategy(applyContradiction);
        gc.applyStrategies();
        repaint();
    }//GEN-LAST:event_StratContradictionActionPerformed

    private void SettingRecursiveStrategyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_SettingRecursiveStrategyActionPerformed
        applyRecursive = !applyRecursive;
        gc.setApplyUntilNoChange(applyRecursive);
        repaint();
    }//GEN-LAST:event_SettingRecursiveStrategyActionPerformed

    private void PuzzleUndoAllActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_PuzzleUndoAllActionPerformed
        if (gc.getGameState() != null) {
            gc.getGameState().undoAll();
            repaint();
        }
    }//GEN-LAST:event_PuzzleUndoAllActionPerformed

    private void PuzzleRedoAllActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_PuzzleRedoAllActionPerformed
        if (gc.getGameState() != null) {
            gc.getGameState().redoAll();
            repaint();
        }
    }//GEN-LAST:event_PuzzleRedoAllActionPerformed

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        if (backtrackWorker != null) {
            backtrackWorker.abort();
        }
    }//GEN-LAST:event_jButton1ActionPerformed
    //</editor-fold>

    /**
     * Sends a new message to the logger
     *
     * @param msg The message to send
     * @param type The type of message to send
     */
    private void outputMessage(String msg, String type) {
        if (type.equals("Warning")) {
            logger.warning(msg);
        } else {
            logger.info(msg);
        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info :
                    javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException |
                IllegalAccessException |
                javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName())
                    .log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                new MainFrame().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenu ApplyStrategies;
    private javax.swing.JMenuItem AssistanceCheck;
    private javax.swing.JMenuItem AssistanceSolveAll;
    private javax.swing.JMenu AssitanceSolve;
    private javax.swing.JMenuItem AssitanceSolveOne;
    private javax.swing.JTextPane DebugPaneText;
    private javax.swing.JScrollPane DebugScrollPane;
    private javax.swing.JMenuItem FileOpen;
    private javax.swing.JMenuItem FileQuit;
    private javax.swing.JMenu MenuAssist;
    private javax.swing.JMenuBar MenuBar;
    private javax.swing.JMenu MenuEdit;
    private javax.swing.JMenu MenuOpen;
    private javax.swing.JMenuItem MenuSave;
    private javax.swing.JMenu MenuSettings;
    private javax.swing.JMenuItem PuzzleRedo;
    private javax.swing.JMenuItem PuzzleRedoAll;
    private javax.swing.JMenuItem PuzzleUndo;
    private javax.swing.JMenuItem PuzzleUndoAll;
    private javax.swing.JCheckBoxMenuItem SettingEditMode;
    private javax.swing.JCheckBoxMenuItem SettingRecursiveStrategy;
    private javax.swing.JCheckBoxMenuItem SettingShowErrors;
    private javax.swing.JCheckBoxMenuItem StratContradiction;
    private javax.swing.JCheckBoxMenuItem StratFillColumnRow;
    private javax.swing.JCheckBoxMenuItem StratFillThird;
    private javax.swing.JProgressBar backtrackerProgress;
    private javax.swing.JButton jButton1;
    private gui.PuzzlePanel puzzlePanel;
    // End of variables declaration//GEN-END:variables
    /**
     * The handle for the separate thread
     */
    private BacktrackWorker backtrackWorker;

    private class BacktrackWorker extends SwingWorker<Grid, Void>
            implements BacktrackListener {

        private Backtracker backtracker = new Backtracker();
        private int solutions;

        /**
         * Default constructor for the BacktrackerWorker
         *
         * @param findOne Whether we should find only one solution or more
         */
        BacktrackWorker(boolean findOne) {
            backtrackerProgress.setValue(0);
            this.solutions = 0;
            this.findOne = findOne;
        }
        private boolean findOne;

        @Override
        protected Grid doInBackground() {
            return backtracker.solve(
                    gc.loadString(gc.getGameState().toString()), findOne, this);
        }

        /**
         * Aborts work of the backtrackworker
         */
        public void abort() {
            backtracker.abort();
        }

        /**
         * After the backtracker is finished, the end result can be executed and
         * shown
         */
        @Override
        protected void done() {
            backtrackerProgress.setValue(100);
            outputMessage("Possible solutions found, "
                    + "total amount of solutions: "
                    + solutions, "Info");
            DebugPaneText.setCaretPosition(DebugPaneText.getDocument().getLength());
        }

        @Override
        public void solutionGenerated(String solution) {
            if (findOne && solutions == 0) {
                gc.setGameState(gc.loadString(solution));
                puzzlePanel.setPuzzle(gc.getGameState());
                outputMessage("Number of solutions found: ",
                        "Info");
                repaint();
            }
            solutions++;
            outputMessage("Found solution: #" + solutions
                    + System.lineSeparator() + solution, "Info");
            backtrackerProgress.setValue(solutions % 100);
        }
    }
}
